# Component Generation Scripts

This folder contains tools for generating the Python class definitions used by ESApp
from PowerWorld's schema definition file.

## Overview

The `esapp/components/` module contains auto-generated Python code that defines:
- **grid.py** - GObject subclasses for all PowerWorld object types (Bus, Gen, Load, Branch, etc.)
- **ts_fields.py** - Transient Stability field constants for IDE autocomplete (TS, TSField)

These files are generated by parsing the `PWRaw` schema file exported from PowerWorld.

## Files in This Directory

| File | Description |
|------|-------------|
| `generate_components.py` | Python script that parses PWRaw and generates grid.py and ts_fields.py |
| `PWRaw` | Tab-separated schema file exported from PowerWorld containing all object/field definitions |

## Running the Generator

To regenerate the component files after updating the PWRaw schema:

```bash
cd esapp/components
python generate_components.py
```

This will regenerate:
- `grid.py` - All GObject subclasses
- `ts_fields.py` - TS field constants

## Usage in Code

After generation, import components from the `esapp.components` module:

```python
from esapp.components import Bus, Gen, Load, Branch, TS, TSField

# Use grid components
df = wb[Bus, Bus.BusNum, Bus.BusName, Bus.BusPUVolt]

# Use TS fields for dynamics simulation
wb.dyn.watch(Gen, [TS.Gen.P, TS.Gen.Speed, TS.Gen.Delta])
```

---

# PWRaw File Schema Description

**File Format:** Tab-Separated Values (TSV)
**Purpose:** Defines the data structure, variable types, and identifier logic for power system objects.

## 1. Column Definitions
The file is organized hierarchically: **Object Type** headers define the category (e.g., `Gen`), followed by rows of variables for that object.

| Col | Field Name | Content | Description |
| :--- | :--- | :--- | :--- |
| **1** | **Object Type** | String | The object class (e.g., `Gen`, `Load`). *Only appears on the header row.* |
| **2** | **SUBDATA** | Flag | `Yes` if nested sub-data sections are allowed; otherwise blank. |
| **3** | **Key/Required** | Symbol | **The Priority Code.** Defines if a field is a Key (ID), a Base Value, or standard data. (See Section 2). |
| **4** | **Variable Name** | String | The internal variable ID used in scripting. |
| **5** | **Concise Name** | String | A shorter alias for the variable. |
| **6** | **Type** | Type | Data type: `Integer`, `Real` (float), or `String`. |
| **7** | **Description** | String | Human-readable explanation of the field. |
| **8** | **Available List** | String | The GUI menu path where this field is found. |
| **9** | **Enterable** | Flag | `Yes` = Editable by user. Blank = Read-only/Calculated. |

---

## 2. Key & Priority Legend (Column 3)
These symbols define exactly how the software identifies objects and prioritizes data.

| Symbol | Priority Type | Description |
| :--- | :--- | :--- |
| **`*`** | **Primary Key** | The main unique identifier (e.g., `BusNum` for a Bus). |
| **`*A*`** | **Alternate Key** | A unique Name/String that can replace the Primary Key (e.g., `BusName`). |
| **`*1*`** | **Composite Key 1** | The first part of a multi-part ID (usually "From Bus" or Location). |
| **`*2*`** | **Composite Key 2** | The second part of a multi-part ID (usually "To Bus"). |
| **`*3*`** | **Composite Key 3** | The third part of a multi-part ID (e.g., Tertiary winding bus). |
| **`*2B*`** | **Secondary ID** | A string ID used to distinguish devices at the same location (e.g., `GenID`). |
| **`*4B*`** | **Circuit ID** | A string ID used to distinguish parallel branches between the same buses. |
| **`**`** | **Base Value** | A fundamental physical parameter required for the model (e.g., `NomVolt`). |
| **`<`** | **Standard Field** | A regular property, setting, or status flag. |

---

## 3. Object Identifier Examples
How the symbols in **Column 3** combine to form unique keys for common objects:

| Object Type | Key Structure | Explanation |
| :--- | :--- | :--- |
| **Simple Object** | `*1*` | Identified by a single Number (e.g., **Bus**). |
| **Generator / Load** | `*1*` + `*2B*` | Identified by **Location** (BusNum) + **ID** (GenID/LoadID). |
| **Line / Branch** | `*1*` + `*2*` + `*4B*` | Identified by **From Bus** + **To Bus** + **Circuit ID**. |
| **3-Winding XF** | `*1*` + `*2*` + `*3*` | Identified by **Primary** + **Secondary** + **Tertiary** Bus Numbers. |

---

## 4. Primitive Data Types (Column 6)
* **Integer:** Whole numbers (e.g., Bus Numbers, Status flags).
* **Real:** Floating-point numbers (e.g., Voltage, MW, Resistance).
* **String:** Text (e.g., Names, "Yes/No", Labels).

---

# SubData

SubData sections store nested/hierarchical data that belongs to a parent object. They appear in AUX files immediately after the parent record and are NOT available through CSV exports.

### **1. General SubData Block Structure**

| Component | Format / Syntax | Notes |
| :--- | :--- | :--- |
| **Start Tag** | `<SUBDATA ObjectType>` | Case-insensitive; `ObjectType` indicates the class of nested data. |
| **End Tag** | `</SUBDATA>` | Terminates the block. |
| **Location** | Immediately follows the parent `DATA` record. | The SubData block belongs to the immediately preceding row in the main `DATA` section. |
| **Comments** | `// Comment Text` | Supported within the block; parsers should ignore lines starting with `//`. |

### **2. Value Formatting Rules**

**IMPORTANT:** Both formats may appear in the same file. Parsers must detect dynamically.

| Style | Syntax | Detection | Regex Pattern |
| :--- | :--- | :--- | :--- |
| **Bracketed** | `[Val1, Val2], [Val3, Val4]` | Line contains `[` | `\[(.*?)\]` |
| **Space Delimited** | `Val1 Val2 Val3` | No brackets | `(?:[^\s"]|"(?:\\.|[^"])*")+` |
| **Quoted Strings** | `"Val With Space"` | Quotes preserve whitespace | Strip quotes after parsing |

### **3. Common SubData Types by Parent Object**

| Parent Object | SubData Type | Data Structure | Description |
| :--- | :--- | :--- | :--- |
| **Gen** | `BidCurve` | `MW  Price($/MWh)` | Piece-wise linear cost/bid curve |
| **Gen** | `ReactiveCapability` | `MW  MinMVAR  MaxMVAR` | Reactive capability curve points |
| **Load** | `BidCurve` | `MW  Price($/MWh)` | Load benefit/bid curve (prices must increase) |
| **Contingency** | `CTGElement` | `Action  [params...]` | Contingency element definitions |
| **Contingency** | `LimitViol` | Violation data | Limit violations from contingency analysis |
| **Interface** | `InterfaceElement` | Element refs + params | Branch/device membership in interface |
| **Filter** | `Condition` | Filter conditions | Filter definition criteria |
| **Bus** | `MWMarginalCostValues` | `Value` | OPF MW marginal prices |
| **Bus** | `MvarMarginalCostValues` | `Value` | OPF Mvar marginal prices |
| **ColorMap** | `ColorPoint` | `Value  Color  Alpha` | Color contour breakpoints |
| **SuperArea** | `SuperAreaArea` | `AreaNum  PartFactor` | Areas within super area |
| **BackgroundLine** | `Line` | `[x, y]` | Polyline coordinates |

### **4. Accessing SubData in ESA++**

```python
# Get generators with their cost curves and reactive capability
df = saw.GetSubData("Gen", ["BusNum", "GenID", "GenMW"], ["BidCurve", "ReactiveCapability"])

# SubData columns contain lists of lists
for _, row in df.iterrows():
    for mw, price in row["BidCurve"]:       # Each point is [MW, $/MWh]
        print(f"  {mw} MW @ ${price}/MWh")
```

### **5. Discovering Available SubData**

To find which SubData sections are available for an object type:
1. Check Column 2 ("SUBDATA") in `PWRaw.tsv` - objects with `Yes` support SubData
2. Export the object to AUX format and inspect the file
3. Refer to PowerWorld's Auxiliary File Format documentation
